<?php

/**
 * @file
 * Contains nidirect_common.module.
 */

use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Link;
use Drupal\Core\Render\Markup;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\node\Entity\Node;
use Drupal\taxonomy\Entity\Term;
use Drupal\views\ViewExecutable;
use Nette\Utils\Arrays;
use Symfony\Component\HttpFoundation\RedirectResponse;

/**
 * Implements hook_help().
 */
function nidirect_common_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the nidirect_common module.
    case 'help.page.nidirect_common':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Common site wide functions') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_cron().
 */
function nidirect_common_cron() {
  // Process anything in the 'audit_date_updates' queue which was
  // populated by the NidirectMigratePostAuditCommand.
  $queue = \Drupal::service('queue')->get('audit_date_updates');
  $today = date('Y-m-d', \Drupal::time()->getCurrentTime());
  // Only process one item from queue to avoid swamping.
  if ($item = $queue->claimItem()) {
    \Drupal::logger('nidirect-common')->notice(
      'Found @count audit updates to process', ['@count' => $queue->numberOfItems()]
    );
    if (isset($item) && is_object($item)) {
      $nid_list_obj = $item->data;
      if (isset($nid_list_obj) && is_object($nid_list_obj)) {
        // Convert comma separated list of nids into an array.
        $nids = explode(",", $nid_list_obj->nids);
        // Load all nodes at once.
        $nodes = Node::loadMultiple($nids);
        foreach ($nodes as $node) {
          // Double check that auditing is enabled for this content type.
          if ($node->hasField('field_next_audit_due')) {
            // Just set next audit date to today as will show in 'needs audit'
            // report if next audit date is today or earlier.
            $node->set('field_next_audit_due', $today);
            $node->save();
          }
        }
      }
    }
    $queue->deleteItem($item);
    \Drupal::logger('nidirect-common')->notice(
      'One item processed from audit date queue'
    );
  }
}

/**
 * Implements hook_entity_presave().
 */
function nidirect_common_entity_presave(EntityInterface $entity) {
  // This will fire when nodes are created or edited.
  if ($entity->getEntityTypeId() == 'node') {
    /*
     * Programmatically sets the field_top_level_theme based on
     * the parent taxonomy tids of the field_subtheme value.
     */
    if ($entity->hasField('field_top_level_theme') && !empty($entity->get('field_subtheme')->getString())) {
      $subtheme_tid = $entity->get('field_subtheme')->getString();

      $taxonomy = \Drupal::service('entity_type.manager')->getStorage('taxonomy_term');
      $parent_terms = $taxonomy->loadAllParents($subtheme_tid);

      // Check we have a parent term and set as top level term.
      if (!empty($parent_terms)) {
        $root_term = array_pop($parent_terms);
        $entity->set('field_top_level_theme', $root_term);
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Form alter hook for the LinkIt dialogue box
 * presented in the WYSIWYG editor.
 */
function nidirect_common_form_linkit_editor_dialog_form_alter(array &$form, FormStateInterface $form_state) {

  // Hide option to open link in new window.
  $form['linkit_attributes']['target']['#access'] = FALSE;

  // Provide additional guidance information.
  $form['attributes']['href']['#description'] .= '<p>'
    . t('To reference an external URL type the full address, eg: https://www.nidirect.gov.uk') . '</p>'
    . '<p>' . t('To reference an e-mail address type the address and select the "E-mail" option from the dropdown list.')
    . '</p>';
}

/**
 * Implements hook_views_pre_render().
 */
function nidirect_common_views_pre_render(ViewExecutable $view) {
  if ($view->id() == 'publications' && $view->current_display == 'search_page') {
    if (!empty($view->header['area'])) {
      // Generate the header content to show N publication(s).
      $view->header['area']->options['content']['value'] = \Drupal::translation()->formatPlural(
        $view->pager->total_items,
        '@count publication',
        '@count publications',
        ['@count' => $view->pager->total_items]
      );
    }
  }
}

/**
 * Implements hook_preprocess_views_view().
 */
function nidirect_common_preprocess_views_view(&$variables) {
  if ($variables['view']->id() === 'media_entity_browser') {
    $variables['view_array']['#attached']['library'][] = 'nidirect_common/media_entity_browser';
  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function nidirect_common_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {

  // Override misleading layout builder notice.
  if ($entity->bundle() == 'landing_page') {
    // (Layout builder is only used on landing pages for now, this
    // may be expanded to other content types later.)
    $messages = \Drupal::messenger()->messagesByType('status');
    // Retrieve all status messages and delete them.
    \Drupal::messenger()->deleteByType('status');
    foreach ($messages as $message) {
      $message_text = $message->jsonSerialize();
      if ($message_text == 'The layout override has been saved.') {
        // Change text of this message.
        $link_object = Link::createFromRoute($entity->getTitle(),
          'entity.node.canonical',
          ['node' => $entity->id()],
          ['attributes' => ['rel' => 'nofollow']]);
        $message_text = t('Landing page <em class="placeholder">@link</em> has been updated.', ['@link' => $link_object->toString()]);
      }
      // Add the status message back in.
      $newmarkup = Markup::create($message_text);
      \Drupal::messenger()->addMessage($newmarkup);
    }
  }

  if ($entity->bundle() == 'publication' && $view_mode == 'search_result') {
    $build['field_published_date']['#title'] = t('Published');
  }

  // If we don't have the administer content permission,
  // 301 redirect requests to a 'feature' node's
  // canonical path to the front page as these are not intended
  // to be viewed as standalone content.
  if (\Drupal::routeMatch()->getRouteName() == 'entity.node.canonical'
    && $entity->bundle() == 'feature'
      && \Drupal::currentUser()->hasPermission('administer nodes') == FALSE) {

    $response = new RedirectResponse(\Drupal::urlGenerator()->generateFromRoute('<front>'), 301);
    $response->send();
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * Invalidate taxonomy cache tags after node save.
 */
function nidirect_common_node_presave(EntityInterface $entity) {
  // Check that the node is published.
  if ($entity->get('status')->value) {
    $cache_service = \Drupal::service('nidirect_common.invalidate_taxonomy_list_cache_tags');
    $cache_service->invalidateForEntity($entity);
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 *
 * Invalidate taxonomy cache tags after node deletion.
 */
function nidirect_common_node_delete(EntityInterface $entity) {
  $cache_service = \Drupal::service('nidirect_common.invalidate_taxonomy_list_cache_tags');
  $cache_service->invalidateForEntity($entity);
}

/**
 * Implements hook_ENTITY_TYPE_presave() for taxonomy_term entities.
 */
function nidirect_common_taxonomy_term_presave(EntityInterface $entity) {
  // Invalidate 'taxonomy_term_list' custom cache tag for the
  // parent when a new taxonomy term is created.
  if ($entity->get('vid')->target_id == 'site_themes') {
    if ($entity->isNewRevision()) {
      $parent = $entity->get('parent')->target_id;
      if ($parent) {
        Cache::invalidateTags(['taxonomy_term_list:' . $parent]);
      }
    }
  }
}

/**
 * Implements hook_inline_entity_form_entity_form_alter().
 */
function nidirect_common_inline_entity_form_entity_form_alter(&$entity_form, &$form_state) {
  if ($entity_form['#entity_type'] == 'media') {

    // To reduce form clutter, move authoring fields into a
    // collapsed field group.
    $entity_form['authoring_information'] = [
      '#type' => 'details',
      '#title' => t('Authoring information'),
      '#weight' => 5,
    ];

    $entity_form['authoring_information']['created'] = $entity_form['created'];
    unset($entity_form['created']);

    $entity_form['authoring_information']['uid'] = $entity_form['uid'];
    unset($entity_form['uid']);

    $entity_form['authoring_information']['path'] = $entity_form['path'];
    unset($entity_form['path']);

    $entity_form['authoring_information']['revision_log_message'] = $entity_form['revision_log_message'];
    unset($entity_form['revision_log_message']);
  }
}

/**
 * Implements hook_page_attachments_alter().
 */
function nidirect_common_page_attachments_alter(array &$attachments) {
  // Turn off clientside_validation on selected routes. Usually due to
  // interference with other AJAX related features, eg: Media Library.
  $routes = [
    'entity.node.edit_form',
    'entity.media.edit_form',
    'node.add',
    'media.add',
    'layout_builder.overrides.node.view',
  ];

  if (in_array(\Drupal::routeMatch()->getRouteName(), $routes)) {
    // 1 == Yes, 2 == No.
    // See ClientsideValidationjQuerySettingsForm::buildForm().
    $attachments['#attached']['drupalSettings']['clientside_validation_jquery']['validate_all_ajax_forms'] = 2;
  }
}

/**
 * Implements hook_form_media_alter().
 */
function nidirect_common_form_media_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Turn off client-side validation on media base forms.
  if (!empty($form['#after_build'])) {
    foreach ($form['#after_build'] as $key => $value) {
      if ($value == 'clientside_validation_form_after_build') {
        unset($form['#after_build'][$key]);
      }
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function nidirect_common_form_taxonomy_term_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form['vid']['#value'] != 'site_themes') {
    return;
  }

  // Only affect terms from the Site themes vocab.
  if (NestedArray::keyExists($form, ['name', 'widget', 0, 'value'])) {
    $title_description =& $form['name']['widget'][0]['value']['#description'];
    if (empty($title_description)) {
      $title_description = t('
          Used as the theme title on landing pages, and in search results and breadcrumb trails.
          Must be descriptive and concise (60 characters or less).
        ');
      $form['name']['widget'][0]['value']['#description'] = $title_description;
    }
  }

  // Relation is fixed with a weight of 10
  // see https://www.drupal.org/project/drupal/issues/2655328.
  // So we want to change this to something more in line with the broader
  // weight on other form elements.
  $form['relations']['#weight'] = 1;
  $form['relations']['#description'] = t("The primary parent theme where a link to this theme will appear. Sets the breadcrumb trail shown on the theme landing page.");

  $form['description']['widget'][0]['#description'] = t("Optional main body content. Generally not used as it is preferred to show an automatically generated list of the theme's content.");

  if (!empty($form['flag']['hide_theme'])) {
    $form['flag']['hide_theme']['#description'] = t('Prevent links to this theme appearing in navigation menus and on landing pages.');
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function nidirect_common_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  // Add a description to the title field.  This cannot be done in the UI.
  if (NestedArray::keyExists($form, ['title', 'widget', 0, 'value'])) {
    $title_description =& $form['title']['widget'][0]['value']['#description'];
    if (empty($title_description)) {
      $title_description = t('
          Title should be descriptive and concise (60 characters or less). A good title is essential to helping users decide if the
          content will be relevant to them. Google truncates titles longer than 60 to 70 characters.
        ');
    }
  }

  // Update description for Hide Content flag.
  if (NestedArray::keyExists($form, ['flag', 'hide_content'])) {
    $hide_content_description =& $form['flag']['hide_content']['#description'];
    if (empty($hide_content_description)) {
      $hide_content_description = t('
          Check this box to prevent links to this page appearing in navigation menus and landing pages.
        ');
    }
  }

  // Hide Featured Content flag.
  if (NestedArray::keyExists($form, ['flag', 'featured_content'])) {
    $form['flag']['featured_content']['#access'] = FALSE;
  }

  // Hide promote to front-page option.
  $form['promote']['#access'] = FALSE;

  // Update description for Table of Contents option.
  if (array_key_exists('field_toc_enable', $form)) {
    $field_toc_enable_description =& $form['field_toc_enable']['widget']['value']['#description'];
    if (empty($field_toc_enable_description)) {
      $field_toc_enable_description = t(
        'Enable to display a list of quick links to Heading 2s on the page.'
      );
    }
  }

  // Turn off client-side validation on node base forms;
  // it breaks entity browser preview widgets.
  if (!empty($form['#after_build'])) {
    foreach ($form['#after_build'] as $key => $value) {
      if ($value == 'clientside_validation_form_after_build') {
        unset($form['#after_build'][$key]);
      }
    }
  }

  if (array_key_exists('field_top_level_theme', $form)) {
    // Can't use a hidden input type on a container element or
    // set #access to FALSE as we need the form_state values,
    // so using the .hidden class to hide from the user.
    $form['field_top_level_theme']['#attributes']['class'][] = 'hidden';
  }

  // Add extra date validation code to override core bug with
  // date formats as described here
  // https://www.drupal.org/project/drupal/issues/3093267
  $add_date_validation = FALSE;
  foreach ($form as $key => $field) {
    if (preg_match('/_date$/', $key) || preg_match('/_period$/', $key) || preg_match('/publish_on$/', $key)) {
      $add_date_validation = TRUE;
    }
  }
  if ($add_date_validation) {
    array_unshift($form['#validate'], 'nidirect_common_validate_publication_date');
  }
}

/**
 * Form validation handler.
 */
function nidirect_common_validate_publication_date(&$form, FormStateInterface $form_state) {
  // Temporarily store all form errors.
  $form_errors = $form_state->getErrors();

  // Clear the form errors.
  $form_state->clearErrors();

  $date_fields = ['field_published_date',
    'field_last_review_date',
    'field_next_review_date',
    'field_cwp_payments_period',
    'publish_on',
    'unpublish_on',
  ];

  // Now loop through and re-apply all form error messages that
  // don't involve the specified date fields.
  foreach ($form_errors as $name => $error_message) {
    if (preg_match('/^[a-z_]+/', $name, $matches)) {
      $field_name = $matches[0];
      if (in_array($field_name, $date_fields)) {
        continue;
      }
    }
    $form_state->setErrorByName($name, $error_message);
  }

  foreach ($date_fields as $date_field) {
    validate_date_field($form_state, $date_field);
  }
}

/**
 * Utility function to validate dates.
 */
function validate_date_field(&$form_state, $date_field) {
  // Now validate the date and raise an error
  // if it is invalid.
  $dt = $form_state->getValue($date_field);
  if (!empty($dt)) {
    if (preg_match('/_period$/', $date_field)) {
      // Process a date range.
      //
      // Start date.
      $date = $dt[0]['value'];
      if (!($date instanceof DrupalDateTime) || $date->hasErrors()) {
        // Generate error to override the erroneous core error.
        $form_state->setErrorByName($date_field . '][0][value', t('Start date is invalid. Please enter a date in the format dd/mm/yyyy'));
      }
      // End date.
      $date = $dt[0]['end_value'];
      if (!($date instanceof DrupalDateTime) || $date->hasErrors()) {
        // Generate error to override the erroneous core error.
        $form_state->setErrorByName($date_field . '][0][end_value', t('End date is invalid. Please enter a date in the format dd/mm/yyyy'));
      }
    }
    else {
      // Process a single date.
      $date = $dt[0]['value'];
      if (!empty($date)) {
        if (!($date instanceof DrupalDateTime) || $date->hasErrors()) {
          // Generate error to override the erroneous core error.
          if (preg_match('/publish_on$/', $date_field)) {
            $form_state->setErrorByName($date_field, t('Date is invalid. Please enter a date in the format dd/mm/yyyy hh:mm:ss'));
          }
          else {
            $form_state->setErrorByName($date_field, t('Date is invalid. Please enter a date in the format dd/mm/yyyy'));
          }
        }
      }
    }
  }
}

/**
 * Implements hook_shs_js_settings_alter().
 */
function nidirect_common_shs_js_settings_alter(&$settings_shs, $bundle, $field_name) {
  $settings_shs['settings']['anyLabel'] = '- ' . t('None') . ' -';
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 *
 * Overrides the default Telephone Plus widget to provide a
 * default list of title options.
 */
function nidirect_common_field_widget_telephone_plus_widget_form_alter(&$element, FormStateInterface $form_state, $context) {

  $telephone_predefined = [
    'Phone' => 'Phone',
    'Fax' => 'Fax',
    'Textphone' => 'Textphone',
    'Freephone' => 'Freephone',
    'Helpline' => 'Helpline',
    'General enquiries' => 'General enquiries',
    'If calling from outside the UK' => 'If calling from outside the UK',
    'Headquarters' => 'Headquarters',
    'Main office' => 'Main office',
    'Main switchboard' => 'Main switchboard',
    'Billing and payments' => [
      'Billing and payments' => 'Billing and payments',
      'Billing enquiries' => 'Billing enquiries',
      'Payments' => 'Payments',
      'Payment enquiries' => 'Payment enquiries',
      'Payments using a credit or debit card' => 'Payments using a credit or debit card',
    ],
    'Complaints' => [
      'Complaints' => 'Complaints',
      'Complaints helpline' => 'Complaints helpline',
      'Customer complaints' => 'Customer complaints',
    ],
    'Enquiries' => [
      'General enquiries' => 'General enquiries',
      'Billing enquiries' => 'Billing enquiries',
      'Payment enquiries' => 'Payment enquiries',
      'Course enquiries' => 'Course enquiries',
    ],
    'Emergency' => [
      'Emergency out-of-hours' => 'Emergency out-of-hours',
      'Non-emergency' => 'Non-emergency',
      'Non-emergency and general enquiries' => 'Non-emergency and general enquiries',
      '24 hour emergency helpline' => '24 hour emergency helpline',
    ],
    'Freephone numbers' => [
      'Freephone advice line' => 'Freephone advice line',
      'Freephone helpline' => 'Freephone helpline',
    ],
    'Helpline numbers' => [
      'Helpline' => 'Helpline',
      'Freephone helpline' => 'Freephone helpline',
      'Helpline for adults (18+)' => 'Helpline for adults (18+)',
      'Helpline for young people (under 18)' => 'Helpline for young people (under 18)',
      'National helpline' => 'National helpline',
      'Northern Ireland helpline' => 'Northern Ireland helpline',
      '24 hour helpline' => '24 hour helpline',
    ],
    'Out-of-hours' => [
      'Out-of-hours phone' => 'Out-of-hours phone',
      'Out of office hours phone' => 'Out of office hours phone',
    ],
    'Other' => 'Other (please specify)',
  ];

  // Fetch the stored Title field value.
  $telephone_title = $context['items']->get($context['delta'])->get('telephone_title')->getValue();

  // Determine if we have a title matching the predefined options
  // and assign a default value for the select list.
  if (empty($telephone_title)) {
    $telephone_predefined_value = '';
  }
  elseif (in_array($telephone_title, Arrays::flatten($telephone_predefined))) {
    $telephone_predefined_value = $telephone_title;
  }
  else {
    $telephone_predefined_value = 'Other';
  }

  // Select element containing predefined title options.
  $element['telephone_predefined'] = [
    '#type' => 'select',
    '#weight' => '-50',
    '#title' => t('Title'),
    '#options' => $telephone_predefined,
    '#default_value' => $telephone_predefined_value,
    '#attached' => [
      'library' => [
        'nidirect_common/telephone_plus_predefined_titles',
      ],
    ],
    '#attributes' => [
      'class' => ['telephone-predefined'],
    ],
    '#chosen' => FALSE,
    '#empty_value' => '',
  ];

  // Update the default Telephone Plus title field.
  $element['telephone_title']['#title'] = t('Other title');
  $element['telephone_title']['#attributes']['class'][] = 'telephone-title';

  // Display the title textfield if the user selects 'Other'.
  $element['telephone_title']['#states'] = [
    'visible' => [
      ':input[name="field_telephone[' . $context['delta'] . '][telephone_predefined]"]' => ['value' => 'Other'],
    ],
  ];
}

/**
 * Implements hooks_moderation_sidebar_alter().
 */
function nidirect_common_moderation_sidebar_alter(&$build, &$context) {
  if (!empty($build['actions']['secondary']['version_history'])) {
    $revisions_link = Link::createFromRoute(
      $build['actions']['secondary']['version_history']['#title']->__toString(),
      'entity.node.version_history',
      $build['actions']['secondary']['version_history']['#url']->getRouteParameters(),
      $build['actions']['secondary']['version_history']['#url']->getOptions()
    );

    // Replace the URL of revisions link with the updated Link Url object.
    $build['actions']['secondary']['version_history']['#url'] = $revisions_link->getUrl();

    // Strip AJAX class to link direct to page.
    $build['actions']['secondary']['version_history']['#attributes']['class'] = array_diff($build['actions']['version_history']['#attributes']['class'], ['use-ajax']);
  }

  if ($context instanceof Node && $context->getType() == 'webform') {
    // Fix obscure off-canvas JS bug by repointing the URL to the underlying
    // canonical test route name.
    if (!empty($build['actions']['secondary']['entity.node.webform.test_form'])) {
      $build['actions']['secondary']['entity.node.webform.test_form']['#url'] = Url::fromRoute(
        'entity.webform.test_form', ['webform' => $context->get('webform')->target_id]
      );
    }
  }
}

/**
 * Implements hook_preprocess_page().
 */
function nidirect_common_preprocess_page(&$variables) {
  if (\Drupal::service('router.admin_context')->isAdminRoute()) {
    return;
  }

  // Similar to how core adds the node object to $variables, we will add
  // the term if we are on a taxonomy page.
  if (\Drupal::routeMatch()->getRouteName() == 'entity.taxonomy_term.canonical') {
    $tid = \Drupal::routeMatch()->getRawParameter('taxonomy_term');
    $variables['term'] = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($tid);
  }

  // Apply link manager library to all non-admin pages.
  $variables['#attached']['library'][] = 'nidirect_common/link_manager';

  // Sometimes $variables['node'] is not a node object, but just contains the
  // nid as a string, so we'll avoid errors and allow for that here.
  if (isset($variables['node']) && is_string($variables['node'])) {
    $variables['node'] = Node::load($variables['node']);
  }

  // Assign our banner image entity, either a node or a taxonomy term.
  if (isset($variables['node'])) {
    $entity = $variables['node'];
  }
  elseif (isset($variables['term'])) {
    $entity = $variables['term'];
  }

  // Fetch and display the node or theme banner image and footer text.
  if (!empty($entity)) {
    $banner_image = _retrieve_hierarchical_field($entity, 'field_banner_image');

    if (!empty($banner_image)) {
      $variables['page']['top_banner']['banner_display'] = $banner_image->view('default');
    }
  }
}

/**
 * Implements hook_preprocess_status_messages().
 */
function nidirect_common_preprocess_status_messages(&$variables) {
  // Add additional explanation to to the oEmbed resource not found message.
  if (isset($variables['message_list']['error'])) {
    $error_messages = $variables['message_list']['error'];

    foreach ($error_messages as $index => $message) {
      if ($message == 'Could not retrieve the oEmbed resource.') {
        $message .= t("This may be due to media being inaccessible or set to private.");
        $variables['message_list']['error'][$index] = $message;
      }
    }
  }
}

/**
 * Returns a value for a field using ancestorial lookup.
 *
 * @param Drupal\Core\Entity\EntityInterface $entity
 *   Node or Term entity.
 * @param string $field
 *   Machine name of the field to lookup.
 *
 * @return string|null
 *   Value for the field, it there is one.
 */
function _retrieve_hierarchical_field(EntityInterface $entity, string $field) {

  $field_value = NULL;

  // Fetch the image banner if the current entity has one.
  if ($entity->hasField($field) && !$entity->get($field)->isEmpty()) {
    $field_value = $entity->get($field)->first();
  }

  // If banner is empty and we are dealing with a node, load the theme term
  // for that node. Otherwise if we're dealing with a term, assign directly.
  // Finally try to extract a banner image from the term.
  if (empty($field_value)) {
    if ($entity instanceof Node && $entity->hasField('field_subtheme')) {
      $term = $entity->get('field_subtheme')->entity;

      if (empty($term)) {
        return;
      }
    }
    elseif ($entity instanceof Term) {
      $term = $entity;
    }

    if (!empty($term)) {
      $field_value = $term->get($field)->first();
    }
  }

  // If we still don't have a banner image, try the parent and grandparent
  // terms for images.
  if (empty($field_value) && !empty($term)) {
    // This issue https://www.drupal.org/node/2019905
    // prevents us from using ->loadParents() as we won't
    // retrieve the root term.
    $ancestors = array_values(\Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadAllParents($term->id()));

    if (!empty($ancestors)) {

      // Remove the current term from the list of ancestors if the current
      // entity is a taxonomy term.
      if (\Drupal::routeMatch()->getParameter('taxonomy_term')) {
        array_shift($ancestors);
      }

      // Navigate to 2 ancestor terms.
      for ($i = 0; $i < 2; $i++) {
        if (array_key_exists($i, $ancestors)) {
          $field_value = $ancestors[$i]->get($field)->first();

          if ($field_value) {
            break;
          }
        }
      }
    }
  }

  return $field_value;
}

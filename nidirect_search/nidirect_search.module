<?php

/**
 * @file
 * Contains nidirect_search.module.
 */

use Drupal\Core\Cache\Cache;
use Drupal\search_api_solr\Utility\Utility as SolrUtility;
use Solarium\Core\Query\QueryInterface;
use Drupal\search_api\Query\QueryInterface as SearchApiQueryInterface;
use Drupal\Core\Language\Language;
use Drupal\Core\Link;

/**
 * Implements hook_preprocess_search_api_spellcheck_did_you_mean().
 *
 * Removes trailing comma on the link text + URL used by the
 * spelling suggestion returned from Solr dictionary.
 */
function nidirect_search_preprocess_search_api_spellcheck_did_you_mean(&$variables) {
  $query_parameter = 'query';

  // Some inconsistencies between views to work around so if empty, try another
  // known value.
  $route_name = \Drupal::routeMatch()->getRouteName();

  if ($route_name == 'view.health_conditions.search_page') {
    $query_parameter = 'query_health_az';
  }
  if ($route_name == 'nidirect_contacts.default') {
    $query_parameter = 'query_contacts_az';
  }

  if ($variables['link'] instanceof Link) {
    $link_text = $variables['link']->getText();
    $variables['link']->setText(str_replace(',', '', $link_text));

    $link_url = $variables['link']->getUrl();
    $link_url_query = $link_url->getRouteParameters()[$query_parameter];

    $link_url->setRouteParameter($query_parameter, str_replace(',', '', $link_url_query));
    $link_url->setOptions([
      'attributes' => [
        'data-self-ref' => ['false'],
      ],
    ]);
  }

  // Fix the cache contexts to be the same based on path and query parameter.
  $variables['#cache']['contexts'] = ['url.query_args:' . $query_parameter];
}

/**
 * Implements hook_search_api_solr_query_alter().
 *
 * Added here because unclear why the spellcheck_en dictionary is not
 * populating/building in Solr.
 * spellcheck_und is an effective mirror image and has the same configuration
 * so can still be safely used.
 *
 * This hook can be removed if/when non-local dev Solr config is
 * more cooperative.
 */
function nidirect_search_search_api_solr_query_alter(QueryInterface $solarium_query, SearchApiQueryInterface $query) {
  $route_name = \Drupal::routeMatch()->getRouteName();
  $query_id = ($route_name == 'nidirect_contacts.default') ? 'query_contacts_az' : 'query';
  $search_term = \Drupal::requestStack()->getCurrentRequest()->get($query_id);

  // Maps to <str name="name">spelling_und</str> in solrconfig_extra.xml.
  $solarium_query->getSpellcheck()->setDictionary('spelling_' . Language::LANGCODE_NOT_SPECIFIED);
  $solarium_query->addParam('spellcheck.onlyMorePopular', FALSE);
  $solarium_query->addParam('spellcheck.extendedResults', FALSE);
  $solarium_query->addParam('spellcheck.count', 1);

  // General search tweaks.
  $solarium_query->addParam('defType', 'edismax');
  $solarium_query->addParam('mm.autoRelax', TRUE);

  // Set the default Solr search index.
  $index_id = 'default_content';

  if ($route_name == 'view.search.search_page') {
    // General search config.
    $solarium_query->addParam('tie', '0.01');
  }

  // Change Solr index to Contacts.
  if ($route_name == 'nidirect_contacts.default' || $route_name == 'nidirect_contacts.letter') {
    $index_id = 'contacts';
    // See https://lucene.apache.org/solr/guide/7_7/the-dismax-query-parser.html#mm-minimum-should-match-parameter.
    // Adjusts the sensitivity of matching based on the number of search terms provided.
    $solarium_query->addParam('mm', '2<67% 5<50%');
  }

  $search_cid = 'solr_elevated_id:' . $index_id . ':' . str_replace(' ', '_', strtolower($search_term));

  $elevation_ids = \Drupal::cache()->get($search_cid)->data;

  if (empty($elevation_ids)) {
    $solr_elevated_entity_storage = \Drupal::entityTypeManager()->getStorage('solr_elevated_id');

    // Search for elevation entities that match the search term and Solr index.
    $solr_elevated_entity_id = $solr_elevated_entity_storage->getQuery()
      ->condition('label', strtolower($search_term))
      ->condition('index', $index_id)
      ->condition('status', '1')
      ->execute();

    if (!is_array($solr_elevated_entity_id)) {
      return;
    }

    $solr_elevated_entity = $solr_elevated_entity_storage->load(current($solr_elevated_entity_id));

    if ($solr_elevated_entity === NULL) {
      return;
    }

    $elevation_ids = explode(',', $solr_elevated_entity->nodes());

    \Drupal::cache()->set($search_cid, $elevation_ids, Cache::PERMANENT);
  }

  // Add elevations to the query.
  if (!empty($elevation_ids)) {
    $solr_hash = SolrUtility::getSiteHash();
    $elevation_items = [];

    // Prefix/suffix our node ids with:
    // <hash>-<index_id>-entity:<entity_type>/<entity_id>:<langcode>.
    foreach ($elevation_ids as $entity_ref) {
      $elevation_items[] = sprintf('%s-%s-entity:%s:%s',
        $solr_hash,
        $index_id,
        'node/' . $entity_ref,
        Language::LANGCODE_NOT_SPECIFIED);
    }

    $solarium_query->addParam('elevateIds', implode(',', $elevation_items));
  }
}
